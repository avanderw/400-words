2019-09-13 12:29: The week is coming to an end as today is Friday. It is concerning how many people pass on work here. Then because the work is passed on between various people until it gets to someone who does the work. Then the questions are asked all the way through that chain on the status of the work. So person A asks B to do something who asks C who asks D. Whilst D is doing the work, then person A asks the status update from B, who asks C who asks D. What is more concerning is that often A asks D after asking B, then B asks D after asking C and then C asks D. The whiplash created for poor D is really disruptive. There should be more people executing than people generating work for other people. The buck stops here, which everyone believes, but does not necessarily implement.

This does create issues though. Whilst work is being executed on by A, B, C, and D together... when there is a conflict in priority on C for instance, e.g. C is asked by A and D to do something. Then C has to make a priority call. Though we have "managers" to solve this problem. The issue is that if everyone is doing, then the information does not filter through the manager. Thus the manager does not have the information to fulfill his role. So the resolution of this is fully funded teams.

However, how can there be a fully funded team left to do their own thing when you create massive dependencies among all teams. In the scenario I am thinking of, it is a platform / server / database / shared service / monitoring, etc. By the very nature of dependency management, the dependent will end up in conflict over any decent duration of a project. The likelihood is compounded when the dependency is reinforced by all consumers of the dependency. If the functionality exists, it is being used for a scenario, when the functionality is reused... it has to cater for two scenarios / business cases. Why does this happen?

The common understanding is that re-use means we do not have to redo the work and can build on the shoulder of giants and save time to get to market. However, the dependency inherently makes the maintenance slower as a change to the dependency has serious ramifications and there are various reasons to change the dependency. Scoping and bounding on dependencies is a must and depth in the dependency graph is also seriously recommended to be shallow.

The argument I counter is that duplication is not evil, in fact it likely has larger benefit than re-use in large system designs. Though that is left to a future discussion.

